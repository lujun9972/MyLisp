#+TITLE: README
#+AUTHOR: lujun9972
#+OPTIONS: ^:{}
* darksun-code-library
  这是一个简单的使用org-mode来收集代码片段的工具. 使用步骤为:

  * 设置`code-library-path'

    该变量的值为存储代码片段文件的目录. 默认为"~/CodeLibrary"

  * 设置`code-library-mode-file-alist'

    该变量指定了哪种编程语言存放到哪个org文件中. 

    改变量的元素格式为'(major-mode . org-filename)

  * 使用时,在Emacs中选中要收集的代码块,然后运行M-x code-library-save-code. 然后输入代码说明并为代码设置tag即可

* org-gamification

  是一个简单的对Org-mode游戏化的尝试,主要就是通过完成任务赚取积分,用然后用积分购买奖励物品.

  * 使用"(org-babel-load-file "org-gamification.org")"加载代码

  * 执行`M-x org-gamification-init'初始化游戏状态(该动作每个org文件只需要做一次)

  * 执行`M-x org-gamification-start'则会进入游戏状态. 这时每完成一个事项即可增加积分.
	
    默认情况下[#A]级任务增加30积分,[#B]级任务增加20积分,[#C]级任务增加10积分.
   
    但可以通过为每个entry设置REWARD属性的方式自定义完成该entry所获得的奖励积分数,需要为整数.

  * 可以使用`M-x org-gamification-add-reward'来添加想购买的奖励物品

    将表示奖励物品的entry设置为完成状态表示购买该奖励物品,需要消耗积分. 若积分不够,则会阻止购买,即该entry无法变为完成状态

  * 执行`M-x org-gamification-end'来退出游戏状态

* autoftp

  由于经常需要在本地编辑代码后上传到远程服务器上编译,因此写了这么个小东西,每次保存文件时自动通过tramp上传到远程服务器上.

  * 配置`autoftp-local-remote-root-alist'变量

    该变量指明了本地路径的文件应该上传到远程服务器的哪个地方,即它为本地项目root与对应的remote地址的alist

    其中remote-root的格式应为/username@ip:/path/to/root/

  * 使用`(require 'autofetp)'加载代码

  * 使用`M-x turn-on-auto-ftp'进入自动上传状态,这时保存本地文件会自动上传到远程服务器上

  * 使用`M-x turn-off-auto-ftp'退出自动上传状态.

* darksun-clean-buffer

  Emacs用久了,就会有很多形形色色的buffer存在,这些buffer不仅耗费系统资源而且显得很凌乱,因此写了个东西自动关闭这些buffer

  * 变量`kill-active-buffer'指示了是否清理正在显示的buffer

  * 变量`kill-process-holding-buffer'指示了是否清理被某个process所持有的buffer
    
     不建议清理被process所持有的buffer,因为关闭该buffer意味着该process也会被kill掉

  * 变量`judge-useless-buffer-functions'指明了使用哪些函数来判断某个buffer是否可以被清理.

    用于判断buffer的函数会接收buffer作为唯一参数,并在buffer为无用时返回非nil
	
	目前提供两个判断函数分别为`judge-useless-buffer-by-time'和`judge-useless-buffer-by-name' 
	
	*`juege-useless-buffer-by-time'的实现上貌似有问题,不建议使用*

  * 若使用judge-useless-buffer-by-name作为判断buffer是否可以被清理的函数,则可以通过配置变量`useless-buffer-name'来将符合其中正则表达式的buffer清理掉

  * 运行`M-x kill-useless-buffers'即可清理掉无用的buffer

  * 若想让Emacs自动清理无用的buffer,可以使用定时器函数`run-with-timer'
	#+BEGIN_SRC emacs-lisp
      (run-with-timer 0 5 #'kill-useless-buffers) ;每5秒清理一次buffer
	#+END_SRC

* darksun-monitor

  
  1. 在使用前,请保证系统有plink或ssh

  2. 加载monitor库:
	 #+BEGIN_SRC emacs-lisp
       (require 'darksun-monitor)
	 #+END_SRC

  3. 创建一个process连接到要监控的远程机器上
	 #+BEGIN_SRC emacs-lisp
       (setq p1 (start-connect-process "IP" "USR" "PWD"))
	 #+END_SRC

  4. 可以创建多个process连接到不同的远程机器上

  5. 创建一个monitor,一个monitor由要执行的检测命令,以及根据检测命令的返回结果指定相应回应命令的rule列表组成
	 #+BEGIN_SRC emacs-lisp
       (setq m1 (make-monitor :exam-cmd "df |grep cnaps2"
                                    :reaction-rules '(("[89]?%" . "echo disk is almost full")
                                                      ("100%" . "echo disk is full! please clean it"))))
	 #+END_SRC
	 
     reaction-rules的格式为由(match . action)组成的alist

     当process的output匹配matchN时,执行actionN命令:若action为字符串,则往process发送action命令,否则action为函数,它接收output作为参数,并返回要发送給process的命令字符串"
	 
  6. 使用add-process-monitor将monitor应用到表示远程机器的process上
	 #+BEGIN_SRC emacs-lisp
       (add-process-monitor p1 m1)
	 #+END_SRC

  7. 可以为一个process添加多个monitor

  8. 执行(active-all-processes-monitors)会执行次所有process中的所有monitor

  9. 若想每隔10s钟自动激活一次process中的所有monitor,可以:
	 #+BEGIN_SRC emacs-lisp
       (setq t1 (run-at-time 0 10 #'active-all-processes-monitors))
	 #+END_SRC

* evolution-game
  
  "land of lisp"中进化模拟游戏的elisp实现.

  其实基本都是照抄书里的...
  
